---
title: "Visualisation"
author: "Serge-√âtienne Parent"
date: "`r format(Sys.Date())`"
output: github_document
---

# Organisation des donn√©es et op√©rations sur les tableaux {#chapitre-tableaux}

***
Ô∏è\ **Objectifs sp√©cifiques**:

√Ä la fin de ce chapitre,

- vous comprendrez les r√®gles guidant la cr√©ation et la gestion des tableaux,

- vous saurez importer et exporter des donn√©es dans R,

- vous saurez effectuer des op√©rations en cascade avec le module tidyverse comme des filtres sur les lignes, des s√©lections de colonnes, des sommaires statistiques et des jointures entre tableaux.

***

Les donn√©es sont utilis√©es √† chaque √©tape dans les flux de travail en sciences. Elles alimentent l'analyse et la mod√©lisation. Les r√©sultats qui en d√©coulent sont aussi des donn√©es qui peuvent alimenter des travaux subs√©quents. Une bonne organisation des donn√©es facilite le flux de travail.

> **Dicton**. Proportions de temps vou√© aux calcul scientifique: 80% de nettoyage de donn√©es mal organis√©es, 20% de calcul.

**Qu'est-ce qu'une donn√©e ?**

De mani√®re abstraite, il s'agit d'une valeur associ√©e √† une variable. Une variable peut √™tre une dimension, une date, une couleur, le r√©sultat d'un test statistique, √† laquelle on attribue la valeur quantitative ou qualitative d'un chiffre, d'une cha√Æne de caract√®re, d'un symbole conventionn√©, etc. 

> Par exemple, lorsque vous commandez un caf√© *latt√©* au lait *v√©gane*, *latt√©* est la valeur que vous attribuez √† la variable *type de caf√©*, et *v√©gane* est la valeur de la variable *type de lait*.

L'exemple est peut-√™tre horrible... peut-√™tre besoin d'un caf√© ... üòâ.

![](https://media.giphy.com/media/3nbxypT20Ulmo/giphy.gif)

Ce chapitre traite de l'importation, l'utilisation et l'exportation de donn√©es structur√©es, en **R**, sous forme de vecteurs, de matrices, de tableaux ou d'ensemble de tableaux (bases de donn√©es).

Bien qu'il soit toujours pr√©f√©rable d'organiser les structures qui accueilleront les donn√©es d'une exp√©rience avant-m√™me de proc√©der √† la collecte de donn√©es, l'analyste doit s'attendre √† r√©organiser ses donn√©es en cours de route. Or, des donn√©es bien organis√©es au d√©part faciliteront aussi leur r√©organisation. Rappelez-vous le **dicton** ci-haut.

Le chapitre d√©bute avec quelques d√©finitions : les donn√©es, les matrices, les tableaux et les bases de donn√©es, ainsi que leur signification en **R**. 

Puis nous verrons comment organiser un tableau selon quelques r√®gles simples, mais importantes pour √©viter les erreurs et les op√©rations fastidieuses pour reconstruire un tableau mal con√ßu.

Ensuite, nous traiterons des formats de tableau courant, pour enfin passer √† l'utilisation de [**`dplyr`**](https://dplyr.tidyverse.org/), le module **tidyverse** pour effectuer des op√©rations sur les tableaux.

## Les collections de donn√©es

Dans le chapitre \@ref(chapitre-intro-a-R), nous avons survol√© diff√©rents types d'objets :

- r√©els, 
- entiers, 
- cha√Ænes de caract√®res 
- et bool√©ens. 

Les donn√©es peuvent appartenir √† d'autres types : 
- dates, 
- cat√©gories ordinales (ordonn√©es : faible, moyen, √©lev√©) 
- et cat√©gories nominales (non ordonn√©es : esp√®ces, cultivars, couleurs, unit√© p√©dologique, etc.). 

Comme mentionn√© en d√©but de chapitre, une donn√©e est une valeur associ√©e √† une variable. Les donn√©es peuvent √™tre organis√©es en collections.

Nous avons aussi vu au chapitre \@ref(chapitre-intro-a-R) que la mani√®re privil√©gi√©e d'organiser des donn√©es √©tait sous forme de **tableau**. De mani√®re g√©n√©rale, un tableau de donn√©es est une organisation de donn√©es en deux dimensions, comportant des *lignes* et des *colonnes*. Il est pr√©f√©rable de respecter la convention selon laquelle **les lignes sont des observations et les colonnes sont des variables**. Ainsi, un tableau est une collection de vecteurs de m√™me longueur, chaque vecteur repr√©sentant une variable. Chaque variable est libre de prendre le type de donn√©es appropri√©. La position d'une donn√©e dans le vecteur correspond √† une observation.

Imaginez que vous consignez des donn√©es de diff√©rents sites (A, B et C), et que chaque site poss√®de ses propres caract√©ristiques. Il est redondant de d√©crire le site pour chaque observation. Vous pr√©f√©rerez cr√©er deux tableaux : un pour d√©crire vos observations, et un autre pour d√©crire les sites. De cette mani√®re, vous cr√©ez une collection de tableaux intereli√©s : une **base de donn√©es**. **R** peut soutirer des donn√©es des bases de donn√©es gr√¢ce au module **`DBI`**, qui n'est pas couvert √† ce stade de d√©veloppement du cours.

Dans **R**, les donn√©es structur√©es en tableaux, ainsi que les op√©rations sur les tableaux, peuvent √™tre g√©r√©s gr√¢ce aux modules **`readr`**, **`dplyr`** et **`tidyr`**, tous des modules faisant partie du m√©ta-module **`tidyverse`**, devenu incontoutnable. Mais avant de se lancer dans l'utilisation de ces modules, voyons quelques r√®gles √† suivre pour bien structurer ses donn√©es en format **`tidy`**, un jargon du **`tidyverse`** qui signifie **proprement organis√©**.

## Organiser un tableau de donn√©es

Afin de rep√©rer chaque cellule d'un tableau, on attribue √† chaque lignes et √† chaque colonne un identifiant **unique**, que l'on nomme **indice** pour les lignes et **ent√™te** pour les colonnes.

> **R√®gle no 1.** Une variable par colonne, une observation par ligne, une valeur par cellule.

Les unit√©s exp√©rimentales sont d√©crites par une ou plusieurs variables par des chiffres ou des lettres. Chaque variable devrait √™tre pr√©sente en une seule colonne, et chaque ligne devrait correspondre √† une unit√© exp√©rimentale o√π ces variables ont √©t√© mesur√©es. La r√®gle parait simple, mais elle est rarement respect√©e. Prenez par exemple le tableau suivant.

| Site | Traitement A | Traitement B | Traitement C |
| :--- | :---: | :---: | :---: |
| Sainte-Souris | 4.1 | 8.2 | 6.8 |
| Sainte-Fourmi | 5.8 | 5.9 | NA |
| Saint-Ours | 2.9 | 3.4 | 4.6 |

*Tableau 1. Rendements obtenus sur les sites exp√©rimentaux selon les traitements.*

Qu'est-ce qui cloche avec ce tableau ? Chaque ligne est une observation, mais contient plusieurs observations d'une m√™me variable, le rendement, qui devient √©tal√© sur plusieurs colonnes. *√Ä bien y penser*, le type de traitement est une variable et le rendement en est une autre :

| Site | Traitement | Rendement |
| :--- | :---: | :---: |
| Sainte-Souris | A | 4.1 |
| Sainte-Souris | B | 8.2 |
| Sainte-Souris | C | 6.8 |
| Sainte-Fourmi | A | 5.8 |
| Sainte-Fourmi | B | 5.9 |
| Sainte-Fourmi | C | NA |
| Saint-Ours | A | 2.9 |
| Saint-Ours | B | 3.4 |
| Saint-Ours | C | 4.6 |

*Tableau 2. Rendements obtenus sur les sites exp√©rimentaux selon les traitements.*

Plus pr√©cis√©ment, l'expression *√† bien y penser* sugg√®re une r√©flexion sur la signification des donn√©es. Certaines variables peuvent parfois √™tre int√©gr√©es dans une m√™me colonne, parfois pas. 

> Par exemple, les concentrations en `cuivre`, `zinc` et `plomb` dans un sol contamin√© peuvent √™tre plac√©s dans la m√™me colonne "**Concentration**" ou d√©clin√©es en plusieurs colonnes `Cu`, `Zn` et `Pb`. 

La premi√®re version trouvera son utilit√© pour cr√©er des graphiques .....(chapitre 3)....., alors que la deuxi√®me favorise le traitement statistique .....(chapitre 5)..... Il est possible de passer d'un format √† l'autre gr√¢ce aux fonctions **`gather()`** et **`spread()`** du module **`tidyr`**.

> **R√®gle no 2.** Un tableau par unit√© observationnelle : ne pas r√©p√©ter les informations.

Reprenons la m√™me exp√©rience. Supposons que vous mesurez la pr√©cipitation (mm) √† l'√©chelle du site.

| Site | Traitement | Rendement | Pr√©cipitations |
| :--- | :---: | :---: | :---: |
| Sainte-Souris | A | 4.1 | 813 |
| Sainte-Souris | B | 8.2 | 813 |
| Sainte-Souris | C | 6.8 | 813 |
| Sainte-Fourmi | A | 5.8 | 642 |
| Sainte-Fourmi | B | 5.9 | 642 |
| Sainte-Fourmi | C | NA | 642 |
| Saint-Ours | A | 2.9 | 1028 |
| Saint-Ours | B | 3.4 | 1028 |
| Saint-Ours | C | 4.6 | 1028 |

*Tableau 3. Rendements obtenus sur les sites exp√©rimentaux selon les traitements.*

Segmenter l'information en deux tableaux serait pr√©f√©rable.

| Site | Pr√©cipitations |
| :--- | :---: |
| Sainte-Souris | 813 |
| Sainte-Fourmi | 642 |
| Saint-Ours | 1028 |

*Tableau 4. Pr√©cipitations sur les sites exp√©rimentaux.*

Les tableaux 2 et 4, ensemble, forment une base de donn√©es (collection organis√©e de tableaux). Les op√©rations de fusion entre les tableaux peuvent √™tre effectu√©es gr√¢ce aux fonctions de jointure (**`left_join()`**, par exemple) du module **`tidyr`**.

> **R√®gle no 3.** Ne pas bousiller les donn√©es.

Par exemple.

- *Ajouter des commentaires dans des cellules*. Si une cellule m√©rite d'√™tre comment√©e, il est pr√©f√©rable de placer les commentaires soit dans un fichier d√©crivant le tableau de donn√©es, soit dans une colonne de commentaire juxtapos√©e √† la colonne de la variable √† commenter. Par exemple, si vous n'avez pas mesur√© le pH pour une observation, n'√©crivez pas "√©chantillon contamin√©" dans la cellule, mais annoter dans un fichier d'explication que l'√©chantillon N¬∞ X a √©t√© contamin√©. Si les commentaires sont syst√©matiques, il peut √™tre pratique de les inscrire dans une colonne **`commentaire_pH`**.

- *Inscription non syst√©matiques*. Il arrive souvent que des cat√©gories d'une variable ou que des valeurs manquantes soient annot√©es diff√©remment. Il arrive m√™me que le s√©parateur d√©cimal soit non syst√©matique, parfois not√© par un point, parfois par une virgule. Par exemple, une fois import√©s dans votre session, les cat√©gories `St-Ours` et `Saint-Ours` seront trait√©es comme deux cat√©gories distinctes. De m√™me, les cellules correspondant √† des valeurs manquantes ne devraient pas √™tre inscrite parfois avec une cellule vide, parfois avec un point, parfois avec un tiret ou avec la mention `NA`. Le plus simple est de laisser syst√©matiquement ces cellules vides.

- *Inclure des notes dans un tableau*. La r√®gle "**une colonne, une variable**" n'est pas respect√©e si on ajoute des notes un peu n'importe o√π sous ou √† c√¥t√© du tableau.

- *Ajouter des sommaires*. Si vous ajoutez une ligne sous un tableau comprenant la moyenne de chaque colonne, qu'est-ce qui arrivera lorsque vous importerez votre tableau dans votre session de travail ? La ligne sera consid√©r√©e comme une observation suppl√©mentaire.

- *Inclure une hi√©rarchie dans le ent√™tes*. Afin de consigner des donn√©es de texture du sol, comprenant la proportion de sable, de limon et d'argile, vous organisez votre ent√™te en plusieurs lignes. Une ligne pour la cat√©gorie de donn√©e, *Texture*, fusionn√©e sur trois colonnes, puis trois colonnes intitul√©es *Sable*, *Limon* et *Argile*. Votre tableau est joli, mais il ne pourra pas √™tre import√© conform√©ment dans votre session de calcul : on recherche **une ent√™te unique par colonne**. Votre tableau de donn√©es devrait plut√¥t porter les ent√™tes *Texture sable*, *Texture limon* et *Texture argile*. Un conseil : r√©server le travail esth√©tique √† la toute fin d'un flux de travail.

## Formats de tableau

Plusieurs outils sont √† votre disposition pour cr√©er des tableaux. Je vous pr√©sente ici les plus communs.

### *xls* ou *xlsx*

Microsoft Excel est un logiciel de type *tableur*, ou chiffrier √©lectronique. L'ancien format *xls* a √©t√© remplac√© par le format *xlsx* avec l'arriv√©e de Microsoft Office 2010. Il s'agit d'un format propri√©taire, dont l'alternative libre la plus connue est le format *ods*, popularis√© par la suite bureautique LibreOffice. Les formats *xls*, *xlsx* ou *ods* sont davantage utilis√©s comme outils de calcul que d'entreposage de donn√©es. Ils contiennent des formules, des graphiques, du formatage de cellule, etc. *Je ne les recommande pas pour stocker des donn√©es*.

### *csv*

Le format **csv**, pour *comma separated values*, est un fichier texte, que vous pouvez ouvrir avec n'importe quel √©diteur de texte brut (Bloc note, [Atom](https://atom.io), [Notepad++](https://notepad-plus-plus.org), etc.). Chaque colonne doit √™tre d√©limit√©e par un caract√®re coh√©rent (conventionnellement **une virgule**, mais en fran√ßais **un point-virgule** ou **une tabulation** pour √©viter la confusion avec le s√©parateur d√©cimal) et chaque ligne du tableau est un retour de ligne. Il est possible d'ouvrir et d'√©diter les fichiers **`.csv`** dans un √©diteur de texte, mais il est plus pratique de les ouvrir avec des tableurs (LibreOffice Calc, Microsoft Excel, Google Sheets, etc.).

**Encodage des fichiers texte**. Puisque le format **csv** est un fichier texte, un souci particulier doit √™tre port√© sur la mani√®re dont le texte est encod√©. Les caract√®res accentu√©s pourrait √™tre import√©s incorrectement si vous importez votre tableau en sp√©cifiant le mauvais encodage. Pour les fichiers en langues occidentales, **l'encodage `UTF-8`** devrait √™tre utilis√©. Toutefois, par d√©faut, Excel utilise un encodage de Microsoft. Si le *csv* a √©t√© g√©n√©r√© par Excel, il est pr√©f√©rable de l'ouvrir avec votre √©diteur de texte et de l'enregistrer dans **l'encodage `UTF-8`**.

### *json*

Comme le format **csv**, le format **json** indique un fichier en texte clair. Il est utilis√© davantage pour le partage de donn√©es des applications web. En analyse et mod√©lisation, ce format est surtout utilis√© pour les donn√©es g√©or√©f√©renc√©es. L'encodage est g√©r√© de la m√™me mani√®re qu'un fichier **csv**.

### SQLite

**SQLite** est une application pour les bases de donn√©es relationnelles de type **SQL** qui n'a pas besoin de serveur pour fonctionner. Les bases de donn√©es SQLite sont encod√©es dans des fichiers portant l'extension **`.db`**, qui peuvent √™tre facilement partag√©s.

### Suggestion

En **csv** pour les petits tableaux, en **sqlite** pour les bases de donn√©es plus complexes. Ce cours se concentre toutefois sur les donn√©es de type *csv*.

## Entreposer ses donn√©es

La mani√®re la plus s√©curis√©e pour entreposer ses donn√©es est de les confiner dans une base de donn√©es s√©curis√©e sur un serveur s√©curis√© dans un environnement s√©curis√© et d'encrypter les communications. C'est aussi la mani√®re la moins accessible. Des espaces de stockage nuagiques, comme Dropbox ou d'autres [options similaires](https://alternativeto.net/software/dropbox/), peuvent √™tre pratiques pour les backups et le partage des donn√©es avec une √©quipe de travail (qui risque en retour de bousiller vos donn√©es). 

Le suivi de version est possible chez certains fournisseurs d'espace de stockage. Mais pour un suivi de version plus rigoureux, les espaces de d√©veloppement (comme **GitHub** et **GitLab**) sont plus appropri√©s (couverts au chapitre \@ref(chapitre-git)). 

Dans tous les cas, il est important de garder (1) des copies anciennes pour y revenir en cas d'erreurs et (2) un petit fichier d√©crivant les changements effectu√©s sur les donn√©es.

## Manipuler des donn√©es en mode tidyverse

Le m√©ta-module **tidyverse** regroupe une collection de pr√©cieux modules pour l'analyse de donn√©es en **R**. Il permet :

- d'importer des donn√©es dans votre session de travail avec **`readr`**, 

- de les explorer avec le module de visualisation **`ggplot2`**, 

- de les transformer avec **`tidyr`** et **`dplyr`** 

- et de les exporter avec **`readr`**. 

Les tableaux de classe **data.frame**, comme ceux de la plus moderne classe **tibble**, peuvent √™tre manipul√©s √† travers le flux de travail pour l'analyse et la mod√©lisation (*chapitres suivants*). 

Ce chapitre est loin de couvrir les nombreuses fonctionnalit√©s qui sont offertes dans le **`tidyverse`**.

### Importer les donn√©es dans la session de travail

Supposons que vous avez bien organis√© vos donn√©es en mode **tidy**. Pour les importer dans votre session et commencer √† les inspecter, vous lancerez une des commandes du module **`readr`**, d√©crites dans la documentation d√©di√©e.

- **`read_csv()`** si le s√©parateur de colonne est une virgule

- **`read_csv2()`** si le s√©parateur de colonne est un point-virgule et que le s√©parateur d√©cimal est une virgule

- **`read_tsv()`** si le s√©parateur de colonne est une tabulation

- **`read_table()`** si le s√©parateur de colonne est un espace blanc

- **`read_delim()`** si le s√©parateur de colonne est un autre caract√®re (*comme le point-virgule*) que vous sp√©cifierez dans l'argument **`delim = ";"**`.

Les principaux arguments sont les suivants :

- **`file`** : le chemin vers le fichier. Ce chemin peut aussi bien √™tre une adresse locale (**`data/...`**) qu'une adresse internet (**`https://...`**).

```{r}
#read.csv("data/...")
#read.csv("https://...")
```

- **`delim`** : le symbole d√©limitant les colonnes dans le cas de **`read_delim`**.

```{r}
#read.delim("data/...", delim = ";")
```

- **`col_names`** : si **`= TRUE`**, la premi√®re ligne est l'ent√™te du tableau, sinon **`= FALSE`**. Si vous sp√©cifiez **un vecteur num√©rique**, ce sont les num√©ros des lignes utilis√©es pour le nom de l'ent√™te. Si vous utilisez **un vecteur de caract√®res**, ce sont les noms des colonnes que vous d√©sirez donner √† votre tableau.

- **`na`** : le symbole sp√©cifiant une valeur manquante. L'argument **`na = ''`** signifie que les cellules vides sont des donn√©es manquantes. Si les valeurs manquantes ne sont pas uniformes, vous pouvez les indiquer dans un vecteur, par exemple **`na = c("", "NA", "NaN", ".", "-")`**.

- **`local`** : cet argument prend une fonction **`local()`** qui peut inclure des arguments de format de temps, mais aussi d'encodage ([voir documentation](https://readr.tidyverse.org/reference/locale.html))

D'autres arguments peuvent √™tre sp√©cifi√©s au besoin, et les r√©p√©ter ici dupliquerait l'information de la documentation de [la fonction **`read_csv()`** de readr](https://readr.tidyverse.org/reference/read_delim.html).

Je d√©conseille d'importer des donn√©es en format xls ou xlsx. Si toutefois cela vous convient, je vous r√©f√®re au module [readxl](https://readxl.tidyverse.org/).

[L'aide-m√©moire de readr](https://github.com/rstudio/cheatsheets/raw/master/data-import.pdf) est √† afficher pr√®s de soi.

[![](https://www.rstudio.com/wp-content/uploads/2015/01/data-import-cheatsheet-1-600x464.png)](https://github.com/rstudio/cheatsheets/raw/master/data-import.pdf)
Aide-m√©moire de readr, source: https://www.rstudio.com/resources/cheatsheets/

Nous allons charger des donn√©es de culture de la chicout√© (*Rubus chamaemorus*), un petit fruit nordique, tir√© de **Parent et al. (2013)**. Ouvrons d'abord le fichier pour v√©rifier les s√©parateurs de colonne et de d√©cimale.

![](images/2_chicoute-csv-atom.png)

Le s√©parateur de colonne est un point-virgule et le d√©cimal est une virgule.

Avec [Atom](https://atom.io/), mon √©diteur de texte pr√©f√©r√©, je vais dans Edit > Select Encoding et j'obtiens bien le UTF-8.

![](images/2_chicoute-csv-encoding.png)

Nous allons donc utiliser `read_csv2()` avec ses arguments par d√©faut.

```{r}
library("tidyverse")
chicoute <- read_csv2('data/chicoute.csv')
```

Quelques commandes utiles pour inspecter le tableau :

- **`head()`** pr√©sente l'ent√™te du tableau, soit ses 6 premi√®res lignes.

```{r}
# head(chicoute)
```

- **`str()`** et **`glimpse()`** pr√©sentent les variables du tableau et leur type - **`glimpse()`** est la fonction tidyverse et **`str()`** est la fonction classique (je pr√©f√®re **`str()`**).

```{r}
# str(chicoute)
```

- **`summary()`** pr√©sente des statistiques de base du tableau.

```{r}
# summary(chicoute)
```

- **`names()`** ou **`colnames()`** sort les noms des colonnes sous forme d'un vecteur.

```{r}
# names(chicoute)
```

- **`dim()`** donne les dimensions du tableau, **`ncol()`** son nombre de colonnes et **`nrow()`** son nombre de lignes.

```{r}
# dim(chicoute)
```

- **`skim()`** est une fonction du module **`skimr`** montrant un portrait graphique et num√©rique du tableau.

```{r}
# devtools::install_github("ropenscilabs/skimr")
# skimr::skim(chicoute)
```

**Extra 1**. Plusieurs modules ne se trouvent pas dans les d√©p√¥t CRAN, mais sont disponibles sur GitHub. Pour les installer, installez d'abord le module devtools disponible sur CRAN. Vous pourrez alors installer les packages de GitHub comme on le fait avec le package skimr.

**Extra 2**. Lorsque je d√©sire utiliser une fonction, mais sans charger le module dans la session, j'utilise la notation `module::fonction`. Comme dans ce cas, pour skimr.

**Exercice**. Inspectez le tableau **chicoute**.

### Comment s√©lectionner et filtrer des donn√©es ?

On utiliser le terme *s√©lectionner* lorsque l'on d√©sire choisir une ou plusieurs lignes et colonnes d'un tableau (la plupart du temps des colonnes). L'action de *filtrer* signifie de s√©lectionner des lignes selon certains crit√®res.

#### S√©lectionner

Voici trois mani√®res de s√©lectionner une colonne en **R**.

- Une m√©thode rapide mais peu expressive consiste √† indiquer les valeurs num√©riques de l'indice de la colonne entre des crochets. Il s'agit d'appeler le tableau suivit de crochets. L'int√©rieur des crochets comprend deux √©l√©ments s√©par√©s par une virgule. Le premier √©l√©ment sert √† filtrer selon l'indice, le deuxi√®me sert √† s√©lectionner selon l'indice. Ainsi:

- **`chicoute[, 1]`** : s√©lectionner la premi√®re colonne

```{r}
# chicoute[, 1]
```

- **`chicoute[, 1:5]`** : s√©lectionner les 5 premi√®res colonnes

```{r}
head(chicoute[, 1:5])
```

- **`chicoute[, c(2, 4, 5)]`** : s√©lectionner les colonnes 2, 4 et 5.

```{r}
head(chicoute[, c(2, 4, 5)])
```

- **`chicoute[c(10, 13, 20), c(2, 4, 5)]`** : s√©lectionner les colonnes 2, 4 et 5 et les lignes 10, 13 et 20.

```{r}
chicoute[c(10, 13, 20), c(2, 4, 5)]
```

- Une autre m√©thode rapide, mais plus expressive, consiste √† appeler le tableau, suivi du symbole **`$`**, puis le nom de la colonne.

> **Truc**. La plupart des IDE, comme RStudio, peuvent vous proposer des colonnes dans une liste. Apr√®s avoir entrer le `$`, taper sur la touche de tabulation : vous pourrez s√©lectionner la colonne dans une liste d√©filante.

![](images/2_auto-complete-cols.png)

- Une autre option est d'inscrire le nom de la colonne, ou du vecteur des colonnes, entre des crochets suivant le nom du tableau, c'est-√†-dire **`chicoute[c("Site", "Latitude_m", "Longitude_m")]`**.

- Enfin, dans une s√©quence d'op√©rations en mode pipeline (chaque op√©ration est mise √† la suite de la pr√©c√©dente en pla√ßant le **pipe** `%>%` entre chacune), il peut √™tre pr√©f√©rable de s√©lectionner des colonnes avec la fonction **`select()`**, par exemple

```{r}
chicoute %>%
  select(Site, Latitude_m, Longitude_m) %>%
  head()
```

La fonction **`select()`** permet aussi de travailler en exclusion. Ainsi pour enlever des colonnes, on placera un **`-`** (*signe de soustraction*) devant le nom de la colonne.

D'autre arguments de **`select()`** permettent une s√©lection rapide. Par exemple, pour obtenir les colonnes contenant des pourcentages :

```{r}
chicoute %>%
  select(ends_with("pourc")) %>%
  head(3)
```

#### Filtrer

Comme c'est le cas de la s√©lection, on pourra filtrer un tableau de plusieurs mani√®res. J'ai d√©j√† pr√©sent√© comment filtrer selon les indices des lignes. Les autres mani√®res reposent n√©anmoins sur une op√©ration logique **`==`**, **`<`**, **`>`** ou **`%in%`** (le **`%in%`** signifie **se trouve parmi** et peut √™tre suivi d'un vecteur de valeur que l'on d√©sire accepter).

Les conditions bool√©ennes peuvent √™tre combin√©es avec les op√©rateurs *et*,  **`&`**, et *ou*, **`|`**. Pour rappel :


| Op√©ration | R√©sultat |
| :--------- | :--------: |
| Vrai **et** Vrai | Vrai |
| Vrai **et** Faux | Faux |
| Faux **et** Faux | Faux |
| Vrai **ou** Vrai | Vrai |
| Vrai **ou** Faux | Vrai |
| Faux **ou** Faux | Faux |

- La m√©thode classique consiste √† appliquer une op√©ration logique entre les crochets, par exemple **`chicoute[chicoute$CodeTourbiere == "BEAU", ]`**. Ceci veut dire, s√©lectionner dans le tableau toutes les observations dont le CodeTourbi√®re est BEAU.

```{r}
# chicoute[chicoute$CodeTourbiere == "BEAU", ]
```

- La m√©thode **tidyverse**, plus pratique en mode pipeline, passe par la fonction **`filter()`**. Le code pr√©c√©dent devient simplement :

```{r}
chicoute %>%
  filter(CodeTourbiere == "BEAU")
```

Combiner le tout.

```{r}
chicoute %>%
  filter(Ca_pourc < 0.4 & CodeTourbiere %in% c("BEAU", "MB", "WTP")) %>%
  select(contains("pourc"))
```

### Le format long et le format large

Dans le tableau **`chicoute`**, chaque √©l√©ment poss√®de sa propre colonne. Si l'on voulait mettre en graphique les boxplot des facettes de concentrations d'azote, de phosphore et de potassium dans les diff√©rentes tourbi√®res, il faudrait obtenir une seule colonne de concentrations.

Pour ce faire, nous utiliserons la fonction **`gather()`** :

- son premier argument **`key`** indique le nom de la colonne des variables, 

- le deuxi√®me argument **`value`** indique le nom de la nouvelle colonne des valeurs. 

- La suite consiste √† d√©crire les colonnes √† inclure ou √† exclure. Dans le cas qui suit, 

- j'exclue **`CodeTourbiere`** de la refonte j'utilise **`sample_n()`** pour pr√©senter un √©chantillon du r√©sultat.

- Notez la ligne comprenant la fonction **`mutate()`**, que l'on verra plus loin. Cette fonction ajoute une colonne au tableau. Dans ce cas-ci, j'ajoute une autre colonne **`ID`** constitu√©e d'une s√©quence de nombres allant de **1** au nombre de lignes du tableau (**il y en a 90**). Cet identifiant unique pour chanque ligne permettra de reconstituer par la suite le tableau initial.

```{r}
chicoute_long <- chicoute %>%
  select(CodeTourbiere, N_pourc, P_pourc, K_pourc) %>%
  mutate(ID = 1:nrow(.)) %>% # mutate ajoute une colonne (ici ID) au tableau
  gather(key = element, value = concentration, -CodeTourbiere, -ID)
chicoute_long %>% sample_n(10)
```

L'op√©ration inverse est `spread()`.

```{r}
chicoute_large <- chicoute_long %>%
  spread(key = "element", value = "concentration") %>%
  select(-ID) # enlever l'identifiant unique
chicoute_large %>% sample_n(10)
```

### Combiner des tableaux

Nous avons introduit plus haut la notion de **base de donn√©es**. Nous voudrions peut-√™tre utiliser le code des tourbi√®res pour inclure leur nom, le type d'essai men√© √† ces tourbi√®res, etc. Importons d'abord le tableau des noms li√©s aux codes.

```{r}
tourbieres <- read_csv2("data/chicoute_tourbieres.csv")
tourbieres
```

Notre information est organis√©e en deux tableaux, li√©s par la colonne **`CodeTourbiere`**. Comment fusionner l'information pour qu'elle puisse √™tre utilis√©e dans son ensemble ? La fonction **`left_join()`** effectue cette op√©ration typique avec les bases de donn√©es.

```{r}
chicoute_merge <- left_join(x = chicoute, y = tourbieres, by = "CodeTourbiere")
# ou bien chicoute %>% left_join(y = tourbieres, by = "CodeTourbiere")
chicoute_merge %>% sample_n(4)
```

D'autres types de jointures sont possibles, et d√©crites en d√©tails dans cette  [documentation](https://dplyr.tidyverse.org/reference/join.html).

[Garrick Aden-Buie](https://www.garrickadenbuie.com/) a pr√©par√© de [jolies animations](https://gist.github.com/gadenbuie/077bcd2700ac1241c65c324581a9f619) pour d√©crire les diff√©rents types de jointures.

- **`left_join(x, y)`** colle **y** √† **x** seulement ce qui dans **y** correspond √† ce que l'on trouve dans **x**.

![](images/2_animated-left-join.gif)

- **`right_join(x, y)`** colle **y** √† **x** seulement ce qui dans **x** correspond √† ce que l'on trouve dans **y**.

![](images/2_animated-right-join.gif) 

-**`inner_join(x, y)`** colle **x** et **y** en excluant les lignes o√π au moins une variable de joint est absente dans **x** et **y**.

![](images/2_animated-inner-join.gif) 

- **`full_join(x, y)`** garde toutes les lignes et les colonnes de **x** et **y**.

![](images/2_animated-full-join.gif) 

### Op√©rations sur les tableaux

Les tableaux peuvent √™tre segment√©s en √©l√©ments sur lesquels on calculera ce qui nous chante.

On pourrait vouloir obtenir :

- la somme avec la function **`sum()`**,

- la moyenne avec la function **`mean()`** ou la m√©diane avec la fonction **`median()`**,

- l'√©cart-type avec la function **`sd()`**,

- les maximum et minimum avec les fonctions **`min()`** et **`max()`**,

- un d√©compte d‚Äôoccurrence avec la fonction **`n()`** ou **`count()`**,

- etc.

Par exemple,

```{r}
mean(chicoute$Rendement_g_5m2, na.rm = TRUE)
```

**En mode classique**, pour effectuer des op√©rations sur des tableaux, on utilisera la fonction **`apply()`**. Cette fonction prend, comme arguments :

- le tableau, 
- l'axe (op√©ration par ligne = 1, op√©ration par colonne = 2), 
- puis la fonction √† appliquer.

```{r}
apply(chicoute %>% 
        select(contains("pourc")), 2, mean)
```

Les op√©ration peuvent aussi √™tre effectu√©es par ligne, par exemple une somme (je garde seulement les 10 premiers r√©sultats).

```{r}
apply(chicoute %>% 
        select(contains("pourc")), 1, sum)[1:10]
```

La fonction √† appliquer peut √™tre personnalis√©e, par exemple :

```{r}
apply(chicoute %>% 
        select(contains("pourc")), 2,
      function(x) (prod(x))^(1/length(x)))
```

Vous reconnaissez cette fonction ? C'√©tait la moyenne g√©om√©trique (la fonction **`prod()`** √©tant le produit d'un vecteur).

**En mode tidyverse**, on aura besoin principalement des fonction suivantes :

* __`group_by()`__ pour effectuer des op√©rations par groupe, l‚Äôop√©ration __`group_by()`__ s√©pare le tableau en plusieurs petits tableaux, en attendant de les recombiner. C'est un peu l'√©quivalent des facettes avec le module de visualisation __`ggplot2`__, que nous explorons au chapitre \@ref(chapitre-visualisation).

* __`summarise()`__ pour r√©duire plusieurs valeurs en une seule, il applique un calcul sur le tableau ou s'il y a lieu sur chaque petit tableau segment√©. Il en existe quelques variantes :
+ __`summarise_all()`__ applique la fonction √† toutes les colonnes.
+ __`summarise_at()`__ applique la fonction aux colonnes sp√©cifi√©es.
+ __`summarise_if()`__ applique la fonction aux colonnes qui ressortent comme __`TRUE`__ selon une op√©ration bool√©enne.

* __`mutate()`__ pour ajouter une nouvelle colonne.
+ Si l'on d√©sire ajouter une colonne √† un tableau, par exemple le sommaire calcul√© avec __`summarise()`__. √Ä l'inverse, la fonction __`transmute()`__ retournera seulement le r√©sultat, sans le tableau √† partir duquel il a √©t√© calcul√©. 

De m√™me que __`summarise()`__, __`mutate()`__ et __`transmute()`__ poss√®dent leurs √©quivalents __`_all()`__, __`_at()`__ et __`_if()`__.

* __`arrange()`__ pour r√©ordonner le tableau
+ On a d√©j√† couvert __`arrange()`__ dans le chapitre 3. Rappelons que cette fonction n'est pas une op√©ration sur un tableau, mais plut√¥t un changement d'affichage en changeant l'ordre d'apparition des donn√©es.

Ces op√©rations sont d√©crites dans l'aide-m√©moire [*Data Transformation Cheat Sheet*](https://github.com/rstudio/cheatsheets/raw/master/data-transformation.pdf).

[![](https://www.rstudio.com/wp-content/uploads/2015/01/data-transformation-cheatsheet-600x464.png)](https://github.com/rstudio/cheatsheets/raw/master/data-transformation.pdf)

Aide-m√©moire de dplyr, source: https://www.rstudio.com/resources/cheatsheets/

Pour effectuer des statistiques par colonne, on utilisera __`summarise`__ pour des statistiques effectu√©es sur une seule colonne. __`summarise`__ peut prendre le nombre d√©sir√© de statistiques dont la sortie est un scalaire.

```{r}
chicoute %>%
  summarise(moyenne = mean(TotalFloral_nombre_m2, na.rm = TRUE),
            ecart_type = sd(TotalFloral_nombre_m2, na.rm = TRUE))
```

Si l'on d√©sire un sommaire sur toutes les variables s√©lectionn√©es, on utilisera __`summarise_all()`__. Pour sp√©cifier que l'on d√©sire la moyenne et l'√©cart-type on inscrit les noms des fonctions dans __`funs()`__.

```{r}
chicoute %>%
  select(contains("pourc")) %>%
  summarise_all(funs(mean, sd))
```

On utilisera __`group_by()`__ pour segmenter le tableau, et ainsi obtenir des statistiques pour chaque groupe.

```{r}
chicoute %>%
  group_by(CodeTourbiere) %>% 
  summarise(moyenne = mean(TotalFloral_nombre_m2, na.rm = TRUE),
            ecart_type = sd(TotalFloral_nombre_m2, na.rm = TRUE))
```

Dans le cas de __`summarise_all`__, les r√©sultats s'affichent de la m√™me mani√®re.

```{r}
chicoute %>%
  group_by(CodeTourbiere) %>%
  select(N_pourc, P_pourc, K_pourc) %>%
  summarise_all(funs(mean, sd))
```

Pour obtenir des statistiques √† chaque ligne, mieux vaut utiliser __`apply()`__, tel que vu pr√©c√©demment. Le point, __`.`__, repr√©sente le tableau dans la fonction.

```{r}
chicoute %>%
  select(contains("pourc")) %>%
  apply(., 1, sum)
```

Prenons ce tableau des esp√®ces menac√©es issu de l'Union internationale pour la conservation de la nature [distribu√©es par l'OCDE](https://stats.oecd.org/Index.aspx?DataSetCode=WILD_LIFE).

```{r warning=FALSE}
library("tidyverse")
especes_menacees <- read_csv('data/WILD_LIFE_09012019174644084.csv')
```

Nous ex√©cutons le pipeline suivant :

```{r}
especes_menacees %>%
  dplyr::filter(IUCN == 'CRITICAL') %>%
  dplyr::select(Country, Value) %>%
  dplyr::group_by(Country) %>% 
  dplyr::summarise(n_critical_species = sum(Value)) %>%
  dplyr::arrange(desc(n_critical_species)) %>%
  dplyr::top_n(10)
```

Ce pipeline consiste √†:

- prendre le tableau especes_menacees, 
- puis, filtrer pour ne retenir que les esp√®ces critiques, 
- puis, s√©lectionner les colonnes des pays et des valeurs (il s'agit du nombre d'esp√®ces), - puis, segmenter le tableaux en plusieurs tableaux selon le pays, 
- puis, appliquer la fonction __`sum()`__ pour chacun de ces petits tableaux (et recombiner ces sommaires), 
- puis, trier les pays en nombre d√©croissant de d√©compte d'esp√®ces, 
- enfin, afficher le top 10.

### Exemple (difficile) - (Extra)

Pour revenir √† notre tableau **`chicoute`**, imaginez que vous aviez une station m√©t√©o (station_A) situ√©e aux coordonn√©es (490640, 5702453) et que vous d√©siriez calculer la distance entre l'observation et la station. Prenez du temps pour r√©fl√©chir √† la mani√®re dont vous proc√©derez ... 

On pourra cr√©er une fonction qui mesure la distance entre un point **x**, **y** et les coordonn√©es de la station A ...

```{r}
dist_station_A <- function (x, y) {
  return(sqrt((x - 490640)^2 + (y - 5702453)^2))
}
```

... puis ajouter une colonne avec mutate gr√¢ce √† une fonction prenant les arguments x et y sp√©cifi√©s.

```{r}
chicoute %>%
  mutate(dist = dist_station_A(x = Longitude_m, y = Latitude_m)) %>%
  select(ID, CodeTourbiere, Longitude_m, Latitude_m, dist) %>%
  top_n(10)
```

Nous pourrions proc√©der de la m√™me mani√®re pour fusionner des donn√©es climatiques. Le tableau **`chicoute`** ne poss√®de pas d'indicateurs climatiques, mais il est possible de les soutirer de stations m√©t√©o plac√©es pr√®s des sites. Ces donn√©es ne sont pas disponibles pour le tableau de la chicout√©, alors j'utiliserai des donn√©es fictives pour l'exemple.

Voici ce qui pourrait √™tre fait.

1. Cr√©er un tableau des stations m√©t√©o ainsi que des indices m√©t√©o associ√©s √† ces stations.
2. Lier chaque site √† une station (√† la main o√π selon la plus petite distance entre le site et la station).
3. Fusionner les indices climatiques aux sites, puis les sites aux mesures de rendement.

Ces op√©rations demandent habituellement du t√¢tonnement. Il serait surprenant que m√™me une personne exp√©riment√©e soit en mesure de compiler ces op√©rations sans obtenir de message d'erreur, et retravailler jusqu'√† obtenir le r√©sultat souhait√©. L'objectif de cette section est de vous pr√©sent√© un flux de travail que vous pourriez √™tre amen√©s √† effectuer et de fournir quelques √©l√©ments nouveau pour mener √† bien une op√©ration. Il peut √™tre frustrant de ne pas saisir toutes les op√©rations : passez √† travers cette section sans jugement. Si vous devez vous frotter √† un probl√®me semblable, vous saurez que vous trouverez dans ce manuel une recette int√©ressante.

```{r}
mes_stations <- data.frame(Station = c('A', 'B', 'C'),
                           Longitude_m = c(490640, 484870, 485929),
                           Latitude_m = c(5702453, 5701870, 5696421), 
                           t_moy_C = c(13.8, 18.2, 16.30),
                           prec_tot_mm = c(687, 714, 732))
mes_stations
```

La fonction suivante calcule la distance entre des coordonn√©es **x** et **y** et chaque station d'un tableau de stations, puis retourne le nom de la station dont la distance est la moindre.

```{r}
dist_station <- function (x, y, stations_df) {
  # stations est le tableau des stations √† trois colonnes
  # 1iere: nom de la station
  # 2ieme: longitude
  # 3ieme: latitude
  distance <- c()
  for (i in 1:nrow(stations_df)) {
    distance[i] <- sqrt((x - stations_df[i, 2])^2 + (y - stations_df[i, 3])^2)
  }
  nom_station <- as.character(stations_df$Station[which.min(distance)])
  return(nom_station)
}
```

Testons la fonction avec des coordonn√©es.

```{r}
dist_station(x = 459875, y = 5701988, stations_df = mes_stations)
```

Nous appliquons cette fonction √† toutes les lignes du tableau, puis en retournons un √©chantillon.

```{r}
chicoute %>%
  #rowwise() %>%
  mutate(Station = dist_station(x = Longitude_m, y = Latitude_m, stations_df = mes_stations)) %>%
  select(ID, CodeTourbiere, Longitude_m, Latitude_m, Station) %>%
  sample_n(10)
```

Cela semble fonctionner. On peut y ajouter un **`left_join()`** pour joindre les donn√©es m√©t√©o au tableau principal.

```{r}
chicoute_weather <- chicoute %>%
  #rowwise() %>%
  mutate(Station = dist_station(x = Longitude_m, y = Latitude_m, stations_df = mes_stations)) %>%
  left_join(y = mes_stations, by = "Station")
chicoute_weather %>% sample_n(10)
```

### Exporter un tableau

Simplement avec `write_csv()`.

```{r}
write_csv(chicoute_weather, "data/chicoute_weather.csv")
```

### Aller plus loin dans le tidyverse

Le livre [R for Data Science](http://r4ds.had.co.nz), de Garrett Grolemund et Hadley Wickham, est un incontournable.

[<img src="http://r4ds.had.co.nz/cover.png" width=200>](http://r4ds.had.co.nz)

## R√©f√©rences

**Parent L.E., Parent, S.√â., Herbert-Gentile, V., Naess, K. et  Lapointe, L. 2013**. Mineral Balance Plasticity of Cloudberry (*Rubus chamaemorus*) in Quebec-Labrador Bogs. American Journal of Plant Sciences, 4, 1508-1520. DOI: 10.4236/ajps.2013.47183
